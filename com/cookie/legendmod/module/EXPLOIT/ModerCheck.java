//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\Наталья\Desktop\project\Decompile\DeobfMineObf\1.12 stable mappings"!

//Decompiled by Procyon!

package com.cookie.legendmod.module.EXPLOIT;

import com.cookie.legendmod.module.*;
import net.minecraft.client.network.*;
import com.cookie.legendmod.*;
import yea.bushroot.clickgui.*;
import net.minecraftforge.fml.common.gameevent.*;
import com.cookie.legendmod.utils.*;
import net.minecraftforge.fml.common.eventhandler.*;
import java.util.*;
import net.minecraftforge.fml.relauncher.*;
import com.google.common.collect.*;
import net.minecraft.world.*;
import net.minecraft.scoreboard.*;

public class ModerCheck extends Module
{
    public TimerUtils timer;
    private static NetHandlerPlayClient nethandlerplayclient;
    private static Ordering<NetworkPlayerInfo> ENTRY_ORDERING;
    private static List<NetworkPlayerInfo> list;
    private static Set<String> names;
    
    public ModerCheck() {
        super("ModerCheck", 0, Category.EXPLOIT);
        this.timer = new TimerUtils();
        Legendmod.instance.settingsManager.rSetting(new Setting("Deley", (Module)this, 1.0, 0.0, 20.0, true));
    }
    
    @Override
    public void onDisable() {
        try {
            ModerCheck.list.clear();
            ModerCheck.names.clear();
        }
        catch (Throwable t) {}
        super.onDisable();
    }
    
    @SubscribeEvent
    public void onPlayerTick(final TickEvent.PlayerTickEvent e) {
        if (ModerCheck.mc.world == null) {
            return;
        }
        ModerCheck.nethandlerplayclient = ModerCheck.mc.player.connection;
        ModerCheck.ENTRY_ORDERING = (Ordering<NetworkPlayerInfo>)Ordering.from((Comparator)new PlayerComparator());
        ModerCheck.list = (List<NetworkPlayerInfo>)ModerCheck.ENTRY_ORDERING.sortedCopy((Iterable)ModerCheck.nethandlerplayclient.getPlayerInfoMap());
        for (final NetworkPlayerInfo playerInfo : ModerCheck.list) {
            System.out.println(playerInfo.getGameProfile().getName());
            final String tname = playerInfo.getGameProfile().getName();
            final int delay = (int)Legendmod.instance.settingsManager.getSettingByName(this.name, "Deley").getValDouble();
            if (!tname.equals(ModerCheck.mc.player.getName()) && !ModerCheck.names.contains(tname)) {
                ModerCheck.names.add(tname);
                if (!this.timer.isDelay(delay * 1000L)) {
                    continue;
                }
                ChatUtils.sendMessage("/pm " + tname + " 1");
                ChatUtils.say("/pm " + tname + " 1");
                this.timer.setLastMS();
            }
        }
    }
    
    static {
        ModerCheck.names = new HashSet<String>();
    }
    
    @SideOnly(Side.CLIENT)
    static class PlayerComparator implements Comparator<NetworkPlayerInfo>
    {
        private PlayerComparator() {
        }
        
        @Override
        public int compare(final NetworkPlayerInfo p_compare_1_, final NetworkPlayerInfo p_compare_2_) {
            final ScorePlayerTeam scoreplayerteam = p_compare_1_.getPlayerTeam();
            final ScorePlayerTeam scoreplayerteam2 = p_compare_2_.getPlayerTeam();
            return ComparisonChain.start().compareTrueFirst(p_compare_1_.getGameType() != GameType.SPECTATOR, p_compare_2_.getGameType() != GameType.SPECTATOR).compare((Comparable)((scoreplayerteam != null) ? scoreplayerteam.getName() : ""), (Comparable)((scoreplayerteam2 != null) ? scoreplayerteam2.getName() : "")).compare((Comparable)p_compare_1_.getGameProfile().getName(), (Comparable)p_compare_2_.getGameProfile().getName()).result();
        }
    }
}
